[TOC]
# C++

- 创建时间: 2025年05月20日 23:12

## 基础知识点
### 隐式转换与explict关键字
- **explict**放在构造函数前，阻止隐式转换，必须显式调用
- 隐式转换的例子
![alt text](assets/20250520--C++/image.png)
![alt text](assets/20250520--C++/image-1.png)

### 运算符及其重载
- 尽量不建议重载运算符，除非有特殊需求
- 重载 **+** 运算符
![alt text](assets/20250520--C++/image-2.png)
- 重载 **<<** 运算符
![alt text](assets/20250520--C++/image-3.png)

### this关键字
- 指向此对象实例的指针
![alt text](assets/20250520--C++/image-4.png)

### 对象生存周期（栈作用域生存期）
- 作用域有哪些
- 生命周期是怎样的
- 生命周期结束后会发生什么
- 错误示例
  ![alt text](assets/20250520--C++/image-5.png)
- 如何正确有效应用（作用域锁，使用栈对象自动管理堆内存周期）
![alt text](assets/20250520--C++/image-6.png)
- 智能停止的定时器，当进入作用域时，定义定时器调用构造函数开始计时，退出作用域时，自动调用析构函数停止计时
- 互斥锁，当进入作用域时，定义互斥锁调用构造函数加锁，退出作用域时，自动调用析构函数解锁

### 智能指针
- 什么是智能指针
- 什么时候应该用智能指针，好处是什么
- 智能指针本质是指针的包装器，可以自动管理指针的生命周期
- unique_ptr，只能有一个指向同一个对象的指针，不能复制或赋值给其他指针
  ![alt text](assets/20250520--C++/image-7.png)
- shared_ptr,允许多个指针指向同一个对象，通过引用计数管理生命周期
- weak_ptr,弱引用，不增加对象的引用计数，只是提供对象的指针访问，常用于解决循环引用问题；
例如，如果两个对象互相持有 shared_ptr 指向对方，会导致引用计数永远不为零，从而造成内存泄漏。通过将其中一方改为 weak_ptr，可以打破这种循环引用关系，确保对象能够被正确释放。


### 复制与拷贝构造函数
- 友元函数
  ![alt text](assets/20250520--C++/image-8.png)
- 浅拷贝，是指只复制对象的指针，而没有复制对象本身的内容。这意味着原始对象和拷贝后的对象共享同一块内存区域，其中一个对象的修改会影响到另一个对象。这通常会导致问题，特别是在涉及到动态分配的内存时，因为两个对象可能会同时释放同一块内存，导致运行时错误。
- 深拷贝，是创建一个新的对象，并将原始对象的所有内容复制到新创建的对象中。这样，即使修改了拷贝后的对象的内容，也不会影响到原始对象。
![alt text](assets/20250520--C++/image-9.png)
![alt text](assets/20250520--C++/image-10.png)
- 尽量通过const引用传递参数，避免不必要的拷贝

### 箭头操作运算符
- 箭头操作符（->）是C++中用于访问指向对象指针的成员的一种运算符。
- 它通常与智能指针一起使用，允许我们通过一个指向对象的指针来访问该对象的成员变量或调用其成员函数，
- 而无需显式地解引用指针。
![alt text](assets/20250520--C++/image-11.png)